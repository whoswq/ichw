### 停机问题

###### 为什么图灵要证明停机问题的不可解
计算机解决了我们生活中的很多问题，会不会有计算机解决不了的问题呢？如果我有一段代码，我是否能找到一个程序或者说一种算法，在不运行我的代码的情况下，可以判断出它是否可以在有限的时间内运行完呢？为了解决这样一个问题，图灵提出了停机问题并证明了其不可解，说明了并不是所有的问题都可以通过计算机来解决。

###### 停机问题的证明方法
反证法：假设存在一个可以判断任何程序H是否停机的算法 f(H)，推出矛盾，从而证明这样的f并不存在，就证明了停机问题不可解。

'''

define f(H)
if H halt:
  f=true
else:
  f=false
  
define g[f(H)]
if f==true:
  g loop forever
else:
  g halt
  
'''

我们此时来考虑g[f(g)],如果此程序g停机了，那么说明f的值是false，说明g不能停机，则推出矛盾；当假设g不能停机时情况类似，因此就说明我们的假设错误，并不存在f，我们不能通过一个算法在不运行程序本身的情况下判断该程序是否能在有限的时间内运行完。

###### 停机问题证明的数学原理
网上说是哥德尔不完备性定理的结果，我真的没怎么看明白。

### 二进制补码的原理
 *  在计算机执行加法时，进位是一件比较容易的事情，我们只要把低一位的进位输出输送到高一位的进位输入中就可以实现任意位数的加法（如果机器允许）；在减法中需要借位，很难通过机器来实现，于是人们改变了负数的存储方式，企图让所有的减法全部变成加法。
(x,y均大于零)我们把 x-y 看作 x+(-y) ，这是把减法看作加法的第一步,我们只要改变负数的存储方式即可。假设两个数的长度都是N，那么我们就考虑给x加上一个什么数相当于给他减了y。2^N 不能被表示，因为第一位会溢出（但是后面的零还是会表示的，不会报错），2^N-y 是可以表示成N位数的，我们设[-y]=2^N-y，那么 x+[-y]=x-y+2^N=x-y（因为只能表示N位，最高为溢出无法表示）。这样我们解决了大部分问题，还有两个小问题需要解决。
 *  计算机如何区分正数和负数：若我们规定x与y只占N-1位，即x与y的第一位均是0，那么对于任意的x，y，正数x首位是0，表示负数含义的[-y]首位是1，这样我们便区分了所有的正数与负数，我们把第一位称作符号位。
 *  0如何表示：表示成N位全是0，由于无论给一个数+0还是-0，结果相同。因此0只有一种表示方法
 *  那么我们定义[x]=x(x>=0),[x]=2^N-1(x<0) 称为x的补码。
 
### 基于 IEEE 754浮点数格式的 16 bit 浮点数表示  8 个小数位
|sign|exp|frac|value|
|:-:|:---:|:---:|:----:|
|0|00000000|0000000|+0|
|1|00000000|0000000|-0|
|0|01111111|0000000|+1|
|1|01111111|0000000|-1|







